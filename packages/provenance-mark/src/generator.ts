// Ported from provenance-mark-rust/src/generator.rs

import { type Cbor } from "@blockchain-commons/dcbor";

import { ProvenanceMarkError, ProvenanceMarkErrorType } from "./error.js";
import { ProvenanceMarkResolution, linkLength } from "./resolution.js";
import { ProvenanceSeed } from "./seed.js";
import { RngState, RNG_STATE_LENGTH } from "./rng-state.js";
import { sha256 } from "./crypto-utils.js";
import { Xoshiro256StarStar } from "./xoshiro256starstar.js";
import { ProvenanceMark } from "./mark.js";

/**
 * Generator for creating provenance mark chains.
 */
export class ProvenanceMarkGenerator {
  private _res: ProvenanceMarkResolution;
  private _seed: ProvenanceSeed;
  private _chainId: Uint8Array;
  private _nextSeq: number;
  private _rngState: RngState;

  private constructor(
    res: ProvenanceMarkResolution,
    seed: ProvenanceSeed,
    chainId: Uint8Array,
    nextSeq: number,
    rngState: RngState,
  ) {
    this._res = res;
    this._seed = seed;
    this._chainId = chainId;
    this._nextSeq = nextSeq;
    this._rngState = rngState;
  }

  res(): ProvenanceMarkResolution {
    return this._res;
  }

  seed(): ProvenanceSeed {
    return this._seed;
  }

  chainId(): Uint8Array {
    return new Uint8Array(this._chainId);
  }

  nextSeq(): number {
    return this._nextSeq;
  }

  rngState(): RngState {
    return this._rngState;
  }

  /**
   * Create a new generator with a seed.
   */
  static newWithSeed(res: ProvenanceMarkResolution, seed: ProvenanceSeed): ProvenanceMarkGenerator {
    // Definitely don't use the bare seed as the chain ID!
    const digest1 = sha256(seed.toBytes());
    const chainId = digest1.slice(0, linkLength(res));
    const digest2 = sha256(digest1);
    return ProvenanceMarkGenerator.new(res, seed, chainId, 0, RngState.fromBytes(digest2));
  }

  /**
   * Create a new generator with a passphrase.
   */
  static newWithPassphrase(
    res: ProvenanceMarkResolution,
    passphrase: string,
  ): ProvenanceMarkGenerator {
    const seed = ProvenanceSeed.newWithPassphrase(passphrase);
    return ProvenanceMarkGenerator.newWithSeed(res, seed);
  }

  /**
   * Create a new generator with custom random data.
   */
  static newUsing(res: ProvenanceMarkResolution, randomData: Uint8Array): ProvenanceMarkGenerator {
    const seed = ProvenanceSeed.newUsing(randomData);
    return ProvenanceMarkGenerator.newWithSeed(res, seed);
  }

  /**
   * Create a new generator with random seed.
   */
  static newRandom(res: ProvenanceMarkResolution): ProvenanceMarkGenerator {
    const seed = ProvenanceSeed.new();
    return ProvenanceMarkGenerator.newWithSeed(res, seed);
  }

  /**
   * Create a new generator with all parameters.
   */
  static new(
    res: ProvenanceMarkResolution,
    seed: ProvenanceSeed,
    chainId: Uint8Array,
    nextSeq: number,
    rngState: RngState,
  ): ProvenanceMarkGenerator {
    const linkLen = linkLength(res);
    if (chainId.length !== linkLen) {
      throw new ProvenanceMarkError(ProvenanceMarkErrorType.InvalidChainIdLength, undefined, {
        expected: linkLen,
        actual: chainId.length,
      });
    }
    return new ProvenanceMarkGenerator(res, seed, chainId, nextSeq, rngState);
  }

  /**
   * Generate the next provenance mark in the chain.
   */
  next(date: Date, info?: Cbor): ProvenanceMark {
    const data = this._rngState.toBytes();
    let rng = Xoshiro256StarStar.fromData(data);

    const seq = this._nextSeq;
    this._nextSeq += 1;

    let key: Uint8Array;
    if (seq === 0) {
      key = new Uint8Array(this._chainId);
    } else {
      // The randomness generated by the PRNG should be portable across implementations
      key = rng.nextBytes(linkLength(this._res));
      this._rngState = RngState.fromBytes(rng.toData());
    }

    // Clone the RNG for generating next_key
    const nextRngData = rng.toData();
    const nextRng = Xoshiro256StarStar.fromData(nextRngData);
    const nextKey = nextRng.nextBytes(linkLength(this._res));

    return ProvenanceMark.new(
      this._res,
      key,
      nextKey,
      new Uint8Array(this._chainId),
      seq,
      date,
      info,
    );
  }

  /**
   * String representation.
   */
  toString(): string {
    return `ProvenanceMarkGenerator(chainID: ${hexEncode(this._chainId)}, res: ${this._res}, seed: ${this._seed.hex()}, nextSeq: ${this._nextSeq})`;
  }

  /**
   * JSON serialization.
   */
  toJSON(): Record<string, unknown> {
    return {
      res: this._res,
      seed: base64Encode(this._seed.toBytes()),
      chainID: base64Encode(this._chainId),
      nextSeq: this._nextSeq,
      rngState: base64Encode(this._rngState.toBytes()),
    };
  }

  /**
   * Create from JSON object.
   */
  static fromJSON(json: Record<string, unknown>): ProvenanceMarkGenerator {
    const res = json.res as ProvenanceMarkResolution;
    const seed = ProvenanceSeed.fromBytes(base64Decode(json.seed as string));
    const chainId = base64Decode(json.chainID as string);
    const nextSeq = json.nextSeq as number;
    const rngState = RngState.fromBytes(base64Decode(json.rngState as string));
    return ProvenanceMarkGenerator.new(res, seed, chainId, nextSeq, rngState);
  }
}

/**
 * Helper function to encode bytes as hex.
 */
function hexEncode(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
}

/**
 * Helper function to encode bytes as base64.
 */
function base64Encode(bytes: Uint8Array): string {
  if (typeof btoa === "function") {
    return btoa(String.fromCharCode(...bytes));
  }
  return Buffer.from(bytes).toString("base64");
}

/**
 * Helper function to decode base64 to bytes.
 */
function base64Decode(str: string): Uint8Array {
  if (typeof atob === "function") {
    const binary = atob(str);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }
  return new Uint8Array(Buffer.from(str, "base64"));
}
